// DiagnosticMessage.c was generated by ProtoGen version 2.17.b

#include "DiagnosticMessage.h"
#include "floatspecial.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Encode a DiagnosticMessage_t structure into a byte array
 *
 * Diagnostic message.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeDiagnosticMessage_t(uint8_t* _pg_data, int* _pg_bytecount, const DiagnosticMessage_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    uint8ToBytes(_pg_user->severity, _pg_data, &_pg_byteindex);

    stringToBytes(_pg_user->text, _pg_data, &_pg_byteindex, 64, 0);

    *_pg_bytecount = _pg_byteindex;

}// encodeDiagnosticMessage_t

/*!
 * \brief Decode a DiagnosticMessage_t structure from a byte array
 *
 * Diagnostic message.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned _pg_bytecount will not be updated.
 */
int decodeDiagnosticMessage_t(const uint8_t* _pg_data, int* _pg_bytecount, DiagnosticMessage_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    _pg_user->severity = (DiagnosticSeverity)uint8FromBytes(_pg_data, &_pg_byteindex);

    stringFromBytes(_pg_user->text, _pg_data, &_pg_byteindex, 64, 0);

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeDiagnosticMessage_t

/*!
 * \brief Create the DiagnosticMessage packet
 *
 * Diagnostic message.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeDiagnosticMessagePacketStructure(CorvoPacket* _pg_pkt, const DiagnosticMessage_t* _pg_user)
{
    uint8_t* _pg_data = getPpdsMotorPodPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes(_pg_user->severity, _pg_data, &_pg_byteindex);

    stringToBytes(_pg_user->text, _pg_data, &_pg_byteindex, 64, 0);

    // complete the process of creating the packet
    finishPpdsMotorPodPacket(_pg_pkt, _pg_byteindex, getDiagnosticMessagePacketID());
}

/*!
 * \brief Decode the DiagnosticMessage packet
 *
 * Diagnostic message.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDiagnosticMessagePacketStructure(const CorvoPacket* _pg_pkt, DiagnosticMessage_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getPpdsMotorPodPacketID(_pg_pkt) != getDiagnosticMessagePacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getPpdsMotorPodPacketSize(_pg_pkt);
    if(_pg_numbytes < getDiagnosticMessageMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getPpdsMotorPodPacketDataConst(_pg_pkt);

    _pg_user->severity = (DiagnosticSeverity)uint8FromBytes(_pg_data, &_pg_byteindex);

    stringFromBytes(_pg_user->text, _pg_data, &_pg_byteindex, 64, 0);

    return 1;
}
// end of DiagnosticMessage.c
