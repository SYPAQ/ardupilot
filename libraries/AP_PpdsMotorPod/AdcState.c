// AdcState.c was generated by ProtoGen version 2.17.b

#include "AdcState.h"
#include "floatspecial.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Encode a AdcState_t structure into a byte array
 *
 * ADC state.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeAdcState_t(uint8_t* _pg_data, int* _pg_bytecount, const AdcState_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    float32ToBeBytes((float)_pg_user->current, _pg_data, &_pg_byteindex);

    float32ToBeBytes((float)_pg_user->voltage, _pg_data, &_pg_byteindex);

    float32ToBeBytes((float)_pg_user->temperature, _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// encodeAdcState_t

/*!
 * \brief Decode a AdcState_t structure from a byte array
 *
 * ADC state.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned _pg_bytecount will not be updated.
 */
int decodeAdcState_t(const uint8_t* _pg_data, int* _pg_bytecount, AdcState_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    _pg_user->current = float32FromBeBytes(_pg_data, &_pg_byteindex);

    _pg_user->voltage = float32FromBeBytes(_pg_data, &_pg_byteindex);

    _pg_user->temperature = float32FromBeBytes(_pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeAdcState_t

/*!
 * \brief Create the AdcState packet
 *
 * ADC state.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeAdcStatePacketStructure(CorvoPacket* _pg_pkt, const AdcState_t* _pg_user)
{
    uint8_t* _pg_data = getPpdsMotorPodPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    float32ToBeBytes((float)_pg_user->current, _pg_data, &_pg_byteindex);

    float32ToBeBytes((float)_pg_user->voltage, _pg_data, &_pg_byteindex);

    float32ToBeBytes((float)_pg_user->temperature, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishPpdsMotorPodPacket(_pg_pkt, _pg_byteindex, getAdcStatePacketID());
}

/*!
 * \brief Decode the AdcState packet
 *
 * ADC state.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeAdcStatePacketStructure(const CorvoPacket* _pg_pkt, AdcState_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getPpdsMotorPodPacketID(_pg_pkt) != getAdcStatePacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getPpdsMotorPodPacketSize(_pg_pkt);
    if(_pg_numbytes < getAdcStateMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getPpdsMotorPodPacketDataConst(_pg_pkt);

    _pg_user->current = float32FromBeBytes(_pg_data, &_pg_byteindex);

    _pg_user->voltage = float32FromBeBytes(_pg_data, &_pg_byteindex);

    _pg_user->temperature = float32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;
}
// end of AdcState.c
