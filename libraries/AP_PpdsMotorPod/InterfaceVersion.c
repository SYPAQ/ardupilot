// InterfaceVersion.c was generated by ProtoGen version 2.17.b

#include "InterfaceVersion.h"
#include "floatspecial.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Encode a InterfaceVersion_t structure into a byte array
 *
 * Interface version information.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeInterfaceVersion_t(uint8_t* _pg_data, int* _pg_bytecount, const InterfaceVersion_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    stringToBytes(_pg_user->id, _pg_data, &_pg_byteindex, 12, 0);

    uint8ToBytes(_pg_user->major, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->minor, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->patch, _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// encodeInterfaceVersion_t

/*!
 * \brief Decode a InterfaceVersion_t structure from a byte array
 *
 * Interface version information.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned _pg_bytecount will not be updated.
 */
int decodeInterfaceVersion_t(const uint8_t* _pg_data, int* _pg_bytecount, InterfaceVersion_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    stringFromBytes(_pg_user->id, _pg_data, &_pg_byteindex, 12, 0);

    _pg_user->major = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->minor = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->patch = uint8FromBytes(_pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeInterfaceVersion_t

/*!
 * \brief Create the InterfaceVersion packet
 *
 * Interface version information.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeInterfaceVersionPacketStructure(CorvoPacket* _pg_pkt, const InterfaceVersion_t* _pg_user)
{
    uint8_t* _pg_data = getPpdsMotorPodPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    stringToBytes(_pg_user->id, _pg_data, &_pg_byteindex, 12, 0);

    uint8ToBytes(_pg_user->major, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->minor, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->patch, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishPpdsMotorPodPacket(_pg_pkt, _pg_byteindex, getInterfaceVersionPacketID());
}

/*!
 * \brief Decode the InterfaceVersion packet
 *
 * Interface version information.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeInterfaceVersionPacketStructure(const CorvoPacket* _pg_pkt, InterfaceVersion_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getPpdsMotorPodPacketID(_pg_pkt) != getInterfaceVersionPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getPpdsMotorPodPacketSize(_pg_pkt);
    if(_pg_numbytes < getInterfaceVersionMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getPpdsMotorPodPacketDataConst(_pg_pkt);

    stringFromBytes(_pg_user->id, _pg_data, &_pg_byteindex, 12, 0);

    _pg_user->major = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->minor = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->patch = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}
// end of InterfaceVersion.c
