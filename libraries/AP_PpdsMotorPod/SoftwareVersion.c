// SoftwareVersion.c was generated by ProtoGen version 2.17.b

#include "SoftwareVersion.h"
#include "floatspecial.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Encode a SoftwareVersion_t structure into a byte array
 *
 * Software version information.
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeSoftwareVersion_t(uint8_t* _pg_data, int* _pg_bytecount, const SoftwareVersion_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    stringToBytes(_pg_user->id, _pg_data, &_pg_byteindex, 12, 0);

    uint8ToBytes(_pg_user->major, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->minor, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->patch, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->build_type, _pg_data, &_pg_byteindex);

    uint32ToBeBytes(_pg_user->build_time, _pg_data, &_pg_byteindex);

    uint32ToBeBytes(_pg_user->git_hash, _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// encodeSoftwareVersion_t

/*!
 * \brief Decode a SoftwareVersion_t structure from a byte array
 *
 * Software version information.
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned _pg_bytecount will not be updated.
 */
int decodeSoftwareVersion_t(const uint8_t* _pg_data, int* _pg_bytecount, SoftwareVersion_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    stringFromBytes(_pg_user->id, _pg_data, &_pg_byteindex, 12, 0);

    _pg_user->major = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->minor = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->patch = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->build_type = (BuildType)uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->build_time = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    _pg_user->git_hash = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeSoftwareVersion_t

/*!
 * \brief Create the SoftwareVersion packet
 *
 * Software version information.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeSoftwareVersionPacketStructure(CorvoPacket* _pg_pkt, const SoftwareVersion_t* _pg_user)
{
    uint8_t* _pg_data = getPpdsMotorPodPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    stringToBytes(_pg_user->id, _pg_data, &_pg_byteindex, 12, 0);

    uint8ToBytes(_pg_user->major, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->minor, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->patch, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->build_type, _pg_data, &_pg_byteindex);

    uint32ToBeBytes(_pg_user->build_time, _pg_data, &_pg_byteindex);

    uint32ToBeBytes(_pg_user->git_hash, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishPpdsMotorPodPacket(_pg_pkt, _pg_byteindex, getSoftwareVersionPacketID());
}

/*!
 * \brief Decode the SoftwareVersion packet
 *
 * Software version information.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeSoftwareVersionPacketStructure(const CorvoPacket* _pg_pkt, SoftwareVersion_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getPpdsMotorPodPacketID(_pg_pkt) != getSoftwareVersionPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getPpdsMotorPodPacketSize(_pg_pkt);
    if(_pg_numbytes < getSoftwareVersionMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getPpdsMotorPodPacketDataConst(_pg_pkt);

    stringFromBytes(_pg_user->id, _pg_data, &_pg_byteindex, 12, 0);

    _pg_user->major = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->minor = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->patch = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->build_type = (BuildType)uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->build_time = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    _pg_user->git_hash = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;
}
// end of SoftwareVersion.c
